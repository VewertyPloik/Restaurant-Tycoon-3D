<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Restaurant Tycoon - Local Save & Multi Food Orders</title>
<style>
  body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #f0f0f0; }
  #money {
    position: fixed; top: 10px; left: 10px;
    background: rgba(0,0,0,0.6); color: white; padding: 8px 12px; border-radius: 6px;
    font-size: 18px; font-weight: bold;
    user-select: none;
    z-index: 10;
  }
  #instructions {
    position: fixed; bottom: 10px; left: 10px;
    background: rgba(0,0,0,0.6); color: white; padding: 8px 12px; border-radius: 6px;
    font-size: 14px; user-select: none;
    z-index: 10;
  }
  #upgrades {
    position: fixed; top: 50px; left: 10px;
    background: rgba(255,255,255,0.95);
    padding: 10px;
    border-radius: 8px;
    max-width: 200px;
    user-select: none;
    z-index: 10;
  }
  #upgrades button {
    display: block;
    width: 100%;
    margin: 6px 0;
    padding: 10px;
    font-size: 18px;
    cursor: pointer;
    border-radius: 6px;
    border: none;
    background-color: #0077ff;
    color: white;
    transition: background-color 0.3s ease;
  }
  #upgrades button:disabled {
    background-color: #999;
    cursor: not-allowed;
  }
  #food-list {
    margin-top: 10px;
    font-size: 14px;
  }
  #food-list span {
    display: inline-block;
    margin-right: 8px;
  }
</style>
</head>
<body>

<div id="money">Money: $0</div>
<div id="instructions">Upgrade food to unlock items. Customers order up to 10 items.</div>

<div id="upgrades">
  <strong>Upgrade Food Supply</strong>
  <div id="food-buttons"></div>
  <div id="food-list"><strong>Unlocked Foods:</strong> <span id="unlocked-foods"></span></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
  (function() {
    // --- Setup Three.js ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0c8ff);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 20);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Floor
    const floorGeo = new THREE.PlaneGeometry(30, 30);
    const floorMat = new THREE.MeshStandardMaterial({color: 0xeeeeee});
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Tables
    const tableGeometry = new THREE.BoxGeometry(3, 0.5, 2);
    const tableMaterial = new THREE.MeshStandardMaterial({color: 0x8b4513});
    const tables = [];

    const tablePositions = [
      [-8, 0.25, -6],
      [-2, 0.25, -6],
      [4, 0.25, -6],
      [-8, 0.25, 0],
      [-2, 0.25, 0],
      [4, 0.25, 0],
    ];

    // Create tables & data objects
    tablePositions.forEach(pos => {
      const table = new THREE.Mesh(tableGeometry, tableMaterial);
      table.position.set(...pos);
      scene.add(table);
      tables.push({
        mesh: table,
        occupied: false,
        foodSprites: [], // multiple food sprites for multiple ordered items
      });
    });

    // Chairs around tables (just visual)
    const chairGeo = new THREE.BoxGeometry(0.8, 1, 0.8);
    const chairMat = new THREE.MeshStandardMaterial({color: 0x654321});
    tables.forEach(({mesh}) => {
      const positions = [
        [mesh.position.x - 1.5, 0.5, mesh.position.z - 0.75],
        [mesh.position.x - 1.5, 0.5, mesh.position.z + 0.75],
        [mesh.position.x + 1.5, 0.5, mesh.position.z - 0.75],
        [mesh.position.x + 1.5, 0.5, mesh.position.z + 0.75],
      ];
      positions.forEach(p => {
        const chair = new THREE.Mesh(chairGeo, chairMat);
        chair.position.set(...p);
        scene.add(chair);
      });
    });

    // Helper: Create emoji sprite
    function createEmojiSprite(emoji) {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.font = '96px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, 64, 64);

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;

      const material = new THREE.SpriteMaterial({map: texture, transparent: true});
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(1.3, 1.3, 1);
      return sprite;
    }

    // Customer emoji options
    const customerEmojis = ['🧍🏻‍♂️', '🧍🏾‍♂️', '🧍🏽‍♂️', '🧍🏻‍♂️'];

    // Money and storage keys
    let money = 0;
    const storageKey = 'restaurantTycoonSave';

    // Food data with price and pay
    const foodTypes = [
      {name: 'Eggs', emoji: '🥚', cost: 0, pay: 5},
      {name: 'Burger', emoji: '🍔', cost: 100, pay: 15},
      {name: 'Taco', emoji: '🌮', cost: 300, pay: 30},
      {name: 'Pizza', emoji: '🍕', cost: 1000, pay: 75},
      {name: 'Pancakes', emoji: '🥞', cost: 500, pay: 20},
      {name: 'Hotdog', emoji: '🌭', cost: 300, pay: 18},
      {name: 'Chocolate', emoji: '🍫', cost: 250, pay: 12},
      {name: 'Ice Cream', emoji: '🍦', cost: 1000, pay: 40},
      {name: 'Pie', emoji: '🥧', cost: 3000, pay: 100},
    ];

    // You must buy to unlock food
    let unlockedFoods = [0]; // Start with Eggs unlocked by default
    let currentFoodIndex = 0; // For UI

    // DOM elements
    const moneyDiv = document.getElementById('money');
    const foodButtonsDiv = document.getElementById('food-buttons');
    const unlockedFoodsSpan = document.getElementById('unlocked-foods');

    // Save & load functions
    function saveGame() {
      const saveData = {
        money,
        unlockedFoods,
      };
      localStorage.setItem(storageKey, JSON.stringify(saveData));
    }
    function loadGame() {
      const saveData = JSON.parse(localStorage.getItem(storageKey));
      if (saveData) {
        money = saveData.money || 0;
        unlockedFoods = saveData.unlockedFoods || [0];
      } else {
        money = 0;
        unlockedFoods = [0];
      }
    }

    // Update money display
    function updateMoney() {
      moneyDiv.textContent = `Money: $${money}`;
    }

    // Update unlocked foods display text
    function updateUnlockedFoodsText() {
      const names = unlockedFoods.map(i => foodTypes[i].emoji + ' ' + foodTypes[i].name);
      unlockedFoodsSpan.textContent = names.join(', ');
    }

    // Create food upgrade buttons dynamically
    function createFoodButtons() {
      foodButtonsDiv.innerHTML = '';
      foodTypes.forEach((food, i) => {
        const btn = document.createElement('button');
        btn.textContent = `${food.emoji} ${food.name} ${food.cost > 0 ? `($${food.cost})` : '(Start)'}`;
        btn.disabled = unlockedFoods.includes(i) || money < food.cost;
        if (unlockedFoods.includes(i)) btn.disabled = true;
        btn.addEventListener('click', () => {
          if (money >= food.cost && !unlockedFoods.includes(i)) {
            money -= food.cost;
            unlockedFoods.push(i);
            unlockedFoods.sort((a,b)=>a-b);
            updateMoney();
            updateUnlockedFoodsText();
            createFoodButtons();
            saveGame();
          }
        });
        foodButtonsDiv.appendChild(btn);
      });
    }

    // Customer class (3D sprite + ordering logic)
    class Customer {
      constructor() {
        this.state = 'waitingInQueue'; // waitingInQueue, goingToTable, sitting, eating, leaving
        this.speed = 3 + Math.random();
        this.targetTable = null;
        this.eatTimer = 0;

        this.position = new THREE.Vector3(0, 0, 18);

        this.emoji = customerEmojis[Math.floor(Math.random() * customerEmojis.length)];
        this.sprite = createCustomerSprite(this.emoji);
        this.sprite.position.copy(this.position);
        scene.add(this.sprite);

        this.queueIndex = null;

        // Order: choose random foods from unlockedFoods, max 10 items total
        this.order = [];
        const maxItems = 10;
        const itemCount = Math.floor(Math.random() * maxItems) + 1; // 1 to 10
        for(let i=0; i<itemCount; i++) {
          const foodIndex = unlockedFoods[Math.floor(Math.random()*unlockedFoods.length)];
          this.order.push(foodIndex);
        }

        // Calculate total pay & eating time (2 seconds base + 1 second per item)
        this.totalPay = this.order.reduce((acc, idx) => acc + foodTypes[idx].pay, 0);
        this.eatingDuration = 2 + this.order.length * 1; // seconds
      }

      update(delta) {
        switch(this.state) {
          case 'waitingInQueue':
            // Line position near entrance
            if (this.queueIndex !== null) {
              const lineX = -8 + this.queueIndex * 2.5;
              const lineZ = 18;
              this.moveTowards(new THREE.Vector3(lineX, 0, lineZ), delta);
            }
            // Check for free table
            const freeTable = tables.find(t => !t.occupied);
            if (freeTable) {
              waitingQueue.shift();
              for (let i = 0; i < waitingQueue.length; i++) {
                waitingQueue[i].queueIndex = i;
              }
              this.queueIndex = null;

              this.targetTable = freeTable;
              freeTable.occupied = true;

              this.state = 'goingToTable';
            }
            break;
          case 'goingToTable':
            // Move to table front
            const targetPos = new THREE.Vector3(this.targetTable.mesh.position.x, 0, this.targetTable.mesh.position.z + 1.5);
            if (this.position.distanceTo(targetPos) > 0.1) {
              this.moveTowards(targetPos, delta);
            } else {
              this.state = 'sitting';
              this.eatTimer = 0;
              // Clear previous food sprites
              this.targetTable.foodSprites.forEach(sprite => scene.remove(sprite));
              this.targetTable.foodSprites = [];

              // Create food sprites for all ordered items, positioned on table in a neat line
              const basePos = this.targetTable.mesh.position.clone();
              basePos.y += 1.3;

              const spacing = 0.3;
              const startX = basePos.x - ((this.order.length - 1) * spacing) / 2;

              this.order.forEach((foodIndex, i) => {
                const foodEmoji = foodTypes[foodIndex].emoji;
                const sprite = createEmojiSprite(foodEmoji);
                sprite.position.set(startX + i * spacing, basePos.y, basePos.z);
                scene.add(sprite);
                this.targetTable.foodSprites.push(sprite);
              });
            }
            break;
          case 'sitting':
            this.eatTimer += delta;
            if (this.eatTimer > this.eatingDuration) {
              this.state = 'leaving';
              this.targetTable.occupied = false;
              // Remove food sprites
              this.targetTable.foodSprites.forEach(sprite => scene.remove(sprite));
              this.targetTable.foodSprites = [];

              money += this.totalPay;
              updateMoney();
              createFoodButtons();
              saveGame();
            }
            break;
          case 'leaving':
            const leavePos = new THREE.Vector3(this.position.x, 0, 25);
            if (this.position.distanceTo(leavePos) > 0.1) {
              this.moveTowards(leavePos, delta);
            } else {
              scene.remove(this.sprite);
              return false;
            }
            break;
        }
        this.sprite.position.copy(this.position);
        return true;
      }

      moveTowards(target, delta) {
        const dir = target.clone().sub(this.position);
        const distance = dir.length();
        if (distance < 0.01) return;
        dir.normalize();
        const moveDist = this.speed * delta;
        if (moveDist > distance) {
          this.position.copy(target);
        } else {
          this.position.add(dir.multiplyScalar(moveDist));
        }
      }
    }

    // Customers & queue
    let spawnTimer = 0;
    const customersList = [];
    const waitingQueue = [];

    function spawnCustomer() {
      if(customersList.length < 20) {
        const customer = new Customer();
        customer.queueIndex = waitingQueue.length;
        waitingQueue.push(customer);
        customersList.push(customer);
      }
    }

    // Animation loop
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      spawnTimer += delta;
      if (spawnTimer > 3) {
        spawnCustomer();
        spawnTimer = 0;
      }

      for(let i = customersList.length -1; i >= 0; i--) {
        if (!customersList[i].update(delta)) {
          customersList.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }

    // Load game before start
    loadGame();
    updateMoney();
    updateUnlockedFoodsText();
    createFoodButtons();

    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  })();
</script>

</body>
</html>
